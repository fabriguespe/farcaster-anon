"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getLatestBlock = exports.hexToBytes = exports.eip712SignerFromMnemonicOrPrivateKey = exports.hexToSigner = void 0;
const core_1 = require("@farcaster/core");
const accounts_1 = require("viem/accounts");
const viem_1 = require("viem");
const chains_1 = require("viem/chains");
function hexToSigner(signerHex) {
    let privateKeyBytes;
    if (signerHex.startsWith('0x')) {
        privateKeyBytes = hexToBytes(signerHex.slice(2));
    }
    else {
        privateKeyBytes = hexToBytes(signerHex);
    }
    return new core_1.NobleEd25519Signer(privateKeyBytes);
}
exports.hexToSigner = hexToSigner;
function eip712SignerFromMnemonicOrPrivateKey(mnemonicOrPrivateKey) {
    let account;
    if (mnemonicOrPrivateKey.startsWith('0x')) {
        account = (0, accounts_1.privateKeyToAccount)(mnemonicOrPrivateKey);
    }
    else if (mnemonicOrPrivateKey.split(' ').length === 1) {
        account = (0, accounts_1.privateKeyToAccount)(`0x${mnemonicOrPrivateKey}`);
    }
    else {
        account = (0, accounts_1.mnemonicToAccount)(mnemonicOrPrivateKey);
    }
    return new core_1.ViemLocalEip712Signer(account);
}
exports.eip712SignerFromMnemonicOrPrivateKey = eip712SignerFromMnemonicOrPrivateKey;
function hexToBytes(hex) {
    if (typeof hex !== 'string') {
        throw new Error('hex string expected, got ' + typeof hex);
    }
    const len = hex.length;
    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
    if (len % 2) {
        throw new Error(`padded hex string expected, got un-padded hex of length ${len}`);
    }
    const array = new Uint8Array(len / 2);
    for (let i = 0; i < array.length; i++) {
        const j = i * 2;
        const hexByte = hex.slice(j, j + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0) {
            throw new Error('Invalid byte sequence');
        }
        array[i] = byte;
    }
    return array;
}
exports.hexToBytes = hexToBytes;
async function getLatestBlock() {
    const publicClient = (0, viem_1.createPublicClient)({
        chain: chains_1.mainnet,
        transport: (0, viem_1.http)(),
    });
    const latestBlock = await publicClient.getBlock();
    return latestBlock.hash;
}
exports.getLatestBlock = getLatestBlock;
//# sourceMappingURL=utils.js.map